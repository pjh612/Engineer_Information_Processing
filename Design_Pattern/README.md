# 디자인 패턴

## 디자인 패넡의 개요

### 디자인 패턴의 정의

- 프로그래머들이 유용하다고 생각되는 객체들간의 일반적인 상호작용 방법과, 반복하여 사용할 수 있는 문제에 대한 솔루션을 기술한 정리 집

### 디자인 패턴의 특징

- 확장성 : 필요에 따른 소프트웨어의 손쉬운 Scale UP / DOWN
- 재사용성 : 재사용을 가능하게 하는 설계를 선택, 재사용 방해하는 설계 배제
- 유지보수성 : 프로그램의 확장성 및 재사용성을 통하여 유지보수에 활용

## GoF 디자인 패턴의 구성요소 및 분류

### GoF 디자인 패턴의 구성요소

- 이름 : 패턴의 내용을 효과적을 전달할 수 있는 이름
- 종류 : 여러 개의 패턴을 체계적으로 분류
  - 생성, 구조, 행위
- 의도 : 이 패턴이 무엇을 하며 어떤 의도로 작성되었는지, 무엇을 하는지 설명하여 기술.
- 구조 : 패턴 안에서 문제를 해결하기 위해 사용되는 클래스와 객체의 구조를 UML 다이어그램으로 표현
- 협력과정 : 각 클래스와 객체가 자신에게 맡겨진 책임을 수행하기 위해 서로 메시지를 주고 받는 과정을 묘사
- Hollywood Principle : 헐리우드 원칙,
  - 상위 클래스가 하위 클래스를 호출(결정함)
  - 구체 클래스에서, 추상클래스를 호출할 수 없음
- 샘플코드 : 특정 언어로 패턴을 구현한 예제, 실제로 사용되는 시스템에서 발견되는 패턴의 예
- 디자인 원칙 : 어플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않은 부분으로부터 분리시킨다.

### 디자인 패턴의 세부 종류

- 생성 패턴(Creational Patterns) : 객체 생성에 관련된 패턴. 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성 제공.

  - 추상 팩토리(Abstract Factory) : 구체적인 클래스를 지정하지 않고 관련성이 있거나, 독립적인 객체들을 생성하기 위한 인터페이스를 제공하는 패턴.
  - 빌더(Builder) : 생산 단계를 캡슐화 하여 구축 공정을 동일하게 이용하도록 하는 패턴
  - 프로토타입(Prototype) : 복사하여 새 개체를 생성할 수 있도록 하는 패턴.
  - 싱글톤(Singleton) : 클래스의 인스턴스가 하나임을 보장, 전역적인 접근점을 제공.
  - 팩토리 메소드(Factory Method) : 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만드는 클래스는 서브클래스에서 결정하도록 하는 패턴.

- 구조 패턴(Structural Patterns) : 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴.

  - 적응자 패턴(Adapter or Wrapper) : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할수 없는 클래스들이 함께 작동하도록 해주는 패턴.
  - 브리지 패턴(Bridge) : 구현부에 추상층을 분리하여 각자 독립적으로 변형할 수 있도록 하는 패턴.
    - 컴포지트 패턴(Composite) : 객체들의 관계를 트리 구조로 구성하여 부분 - 전체 계층을 표현하는 패턴, 사용자가 단일 / 복합객체 모두 동일하게 다루도록 하는 패턴.
  - 데코레이터 패턴(Decorator) : 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 서브클래스 대신 쓸 수 있는 대안이 될 수 있다.
  - 퍼사드 패턴(Facade) : 서브시스템에 있는 인터페이스 집합에 통합된 하나의 인터페이스 제공. 서브 시스템을 조금 더 쉽게 사용하기 위해 고수준의 인터페이스를 정의.
  - 프록시 패턴(Proxy) : 어떤 다른 객체로 접근하는 것을 통제하기 위해 그 객체의 매니저 또는 자리 채움자를 제공하는 패턴.

- 행위 패턴(Behavioral Pattern) : 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴. 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화 하는것에 중점을 두는 방식.
  - 옵저버 패턴(Observer) : 객체들 사이에 1 : N의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존 관계에 있는 모든 객체들이 통지를 받고 자동으로 갱신될 수 있게 만드는 패턴.
  - 상태 패턴(State) : 객체의 내부 상태가 변경될 때 행동을 변경하도록 허락. 객체는 자신의 클래스가 변경되는 것처럼 보이게 됨.
  - 전략 패턴(Strategy) : 동일 계열의 알고리즘들을 정의하고, 각각 캡슐화하며 이들을 상호교환 가능하도록 만드는 것. 알고리즘을 사용하는 사용자로부터 독립적으로 알고리즘이 변경될 수 있도록 하는 패턴.
  - 템플릿 메소드 패턴(Template Method) : 객체의 연산에서 알고리즘의 뼈대만 정의, 나머지는 서브클래스에서 이루어지게 하는 패턴. 템플릿 메소드 패턴은 알고리즘의 구조는 변경하지 않고 알고리즘의 각 단계를 서브클래스에서 재정의하게됨.
  - 비지터 패턴(Visitor) : 객체구조를 이루는 원소에 대해 수행할 연산을 표현. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을 재정의할 수 있다.
  - 역할 사슬 패턴(Chain of Responsibility) : 요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴. 요청을 받는 객체를 연쇄적으로 묶고 객체를 처리할 수 있을 때까지 요청을 전달.
  - 커맨드 패턴(Command) : 요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴.
  - 인터프리터 패턴(Interpreter) : 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴.
  - 이터레이터 패턴(Iterator) : 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴.
  - 미디에이터 패턴(Mediator) : 한 집합에 속해 있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴. 중재자는 객체들이 직접 서로 참조하지 않도록 함으로써 객체들간의 느슨한 연결을 촉진시키며 객체들의 상초작용을 독립적으로 다양화 시킬 수 있도록함.
  - 메멘토(Memento) : 객체를 이전 상태로 복구 시켜야하는 경우, "작업 취소" 요청
